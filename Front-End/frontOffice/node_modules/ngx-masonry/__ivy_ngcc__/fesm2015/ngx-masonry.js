import { isPlatformBrowser } from '@angular/common';
import { EventEmitter, Component, Inject, PLATFORM_ID, ElementRef, Input, Output, Directive, forwardRef, Renderer2, NgModule } from '@angular/core';
import { style, animate, AnimationBuilder } from '@angular/animations';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/animations';

const _c0 = ["ngx-masonry", ""];
const _c1 = ["*"];
let masonryConstructor;
class NgxMasonryComponent {
    constructor(platformId, _element) {
        this.platformId = platformId;
        this._element = _element;
        this.updateLayout = false;
        this.ordered = false;
        // Outputs
        this.layoutComplete = new EventEmitter();
        this.removeComplete = new EventEmitter();
        this.itemsLoaded = new EventEmitter();
        this.pendingItems = [];
    }
    ngOnInit() {
        if (isPlatformBrowser(this.platformId) && masonryConstructor === undefined) {
            masonryConstructor = require('masonry-layout');
        }
        // Create masonry options object
        if (!this.options) {
            this.options = {};
        }
        // Set default itemSelector
        if (!this.options.itemSelector) {
            this.options.itemSelector = '[ngxMasonryItem], ngxMasonryItem';
        }
        this.options['transitionDuration'] = '0s';
        if (isPlatformBrowser(this.platformId)) {
            // Initialize Masonry
            this.masonryInstance = new masonryConstructor(this._element.nativeElement, this.options);
            // Bind to events
            this.masonryInstance.on('layoutComplete', (items) => {
                this.layoutComplete.emit(items);
            });
            this.masonryInstance.on('removeComplete', (items) => {
                this.removeComplete.emit(items);
            });
            this.masonryInstance.items = [];
        }
    }
    ngOnChanges(changes) {
        // only update layout if it's not the first change
        if (changes.updateLayout) {
            if (!changes.updateLayout.firstChange) {
                this.layout();
            }
        }
    }
    ngOnDestroy() {
        if (this.masonryInstance) {
            this.masonryInstance.destroy();
        }
    }
    layout() {
        setTimeout(() => {
            this.masonryInstance.layout();
        });
    }
    reloadItems() {
        setTimeout(() => {
            this.masonryInstance.reloadItems();
        });
    }
    addPendingItem(item) {
        this.pendingItems.push(item);
    }
    add(newItem) {
        if (this.ordered) {
            for (const [index, item] of this.pendingItems.entries()) {
                if (item) {
                    if (item.images && item.images.size === 0) {
                        this.pendingItems[index] = undefined;
                        this.itemLoaded(item);
                        if (index + 1 === this.pendingItems.length) {
                            // All items are loaded
                            this.itemsLoaded.emit(this.pendingItems.length);
                            this.pendingItems = [];
                        }
                    }
                    else {
                        return;
                    }
                }
            }
        }
        else {
            this.itemLoaded(newItem);
        }
    }
    itemLoaded(item) {
        if (isPlatformBrowser(this.platformId)) {
            // Tell Masonry that a child element has been added
            if (item.prepend) {
                this.masonryInstance.prepended(item.element.nativeElement);
            }
            else {
                this.masonryInstance.appended(item.element.nativeElement);
            }
            // Check if first item
            if (this.masonryInstance.items.length === 1) {
                this.masonryInstance.layout();
            }
            item.playAnimation(true);
        }
    }
    remove(element) {
        if (isPlatformBrowser(this.platformId)) {
            // Tell Masonry that a child element has been removed
            this.masonryInstance.remove(element);
            // Layout items
            this.layout();
        }
    }
}
NgxMasonryComponent.ɵfac = function NgxMasonryComponent_Factory(t) { return new (t || NgxMasonryComponent)(ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NgxMasonryComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: NgxMasonryComponent, selectors: [["", "ngx-masonry", ""], ["ngx-masonry"]], inputs: { updateLayout: "updateLayout", ordered: "ordered", options: "options" }, outputs: { layoutComplete: "layoutComplete", removeComplete: "removeComplete", itemsLoaded: "itemsLoaded" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c0, ngContentSelectors: _c1, decls: 1, vars: 0, template: function NgxMasonryComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%] {\n\t\t\tdisplay: block;\n\t\t}"] });
NgxMasonryComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: ElementRef }
];
NgxMasonryComponent.propDecorators = {
    options: [{ type: Input }],
    updateLayout: [{ type: Input }],
    ordered: [{ type: Input }],
    layoutComplete: [{ type: Output }],
    removeComplete: [{ type: Output }],
    itemsLoaded: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxMasonryComponent, [{
        type: Component,
        args: [{ selector: '[ngx-masonry], ngx-masonry', template: '<ng-content></ng-content>', styles: ["\n\t\t:host {\n\t\t\tdisplay: block;\n\t\t}\n\t"] }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }, { type: ɵngcc0.ElementRef }]; }, { updateLayout: [{
            type: Input
        }], ordered: [{
            type: Input
        }], layoutComplete: [{
            type: Output
        }], removeComplete: [{
            type: Output
        }], itemsLoaded: [{
            type: Output
        }], options: [{
            type: Input
        }] }); })();

class NgxMasonryDirective {
    constructor(element, builder, parent, renderer) {
        this.element = element;
        this.builder = builder;
        this.parent = parent;
        this.renderer = renderer;
        this.prepend = false;
        this.animations = {
            show: [
                style({ opacity: 0 }),
                animate('400ms ease-in', style({ opacity: 1 })),
            ],
            hide: [
                style({ opacity: '*' }),
                animate('400ms ease-in', style({ opacity: 0 })),
            ]
        };
    }
    ngOnInit() {
        if (this.parent.options.animations !== undefined) {
            this.animations = this.parent.options.animations;
        }
        this.renderer.setStyle(this.element.nativeElement, 'position', 'fixed');
        this.renderer.setStyle(this.element.nativeElement, 'right', '-150vw');
        this.parent.addPendingItem(this);
    }
    ngAfterViewInit() {
        const images = Array.from(this.element.nativeElement.getElementsByTagName('img'));
        this.images = new Set(images);
        if (images.length === 0) {
            setTimeout(() => {
                this.parent.add(this);
            });
        }
        else {
            for (const imageRef of images) {
                // skip image render check if image has `masonryLazy` attribute
                if (imageRef.hasAttribute('masonryLazy')) {
                    this.imageLoaded(imageRef);
                }
                else {
                    this.renderer.listen(imageRef, 'load', _ => {
                        this.imageLoaded(imageRef);
                    });
                    this.renderer.listen(imageRef, 'error', _ => {
                        this.imageLoaded(imageRef);
                    });
                }
            }
        }
    }
    ngOnDestroy() {
        if (this.images && this.images.size === 0 && this.element.nativeElement.parentNode) {
            this.playAnimation(false);
            this.parent.remove(this.element.nativeElement);
        }
    }
    imageLoaded(image) {
        this.images.delete(image);
        if (this.images.size === 0) {
            this.parent.add(this);
        }
    }
    playAnimation(show) {
        const metadata = show ? this.animations.show : this.animations.hide;
        if (metadata) {
            const player = this.builder.build(metadata).create(this.element.nativeElement);
            player.play();
        }
    }
}
NgxMasonryDirective.ɵfac = function NgxMasonryDirective_Factory(t) { return new (t || NgxMasonryDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.AnimationBuilder), ɵngcc0.ɵɵdirectiveInject(forwardRef(() => NgxMasonryComponent)), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NgxMasonryDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: NgxMasonryDirective, selectors: [["", "ngxMasonryItem", ""], ["ngxMasonryItem"]], inputs: { prepend: "prepend" } });
NgxMasonryDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: AnimationBuilder },
    { type: NgxMasonryComponent, decorators: [{ type: Inject, args: [forwardRef(() => NgxMasonryComponent),] }] },
    { type: Renderer2 }
];
NgxMasonryDirective.propDecorators = {
    prepend: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxMasonryDirective, [{
        type: Directive,
        args: [{
                selector: '[ngxMasonryItem], ngxMasonryItem'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc1.AnimationBuilder }, { type: NgxMasonryComponent, decorators: [{
                type: Inject,
                args: [forwardRef(() => NgxMasonryComponent)]
            }] }, { type: ɵngcc0.Renderer2 }]; }, { prepend: [{
            type: Input
        }] }); })();

class NgxMasonryModule {
}
NgxMasonryModule.ɵfac = function NgxMasonryModule_Factory(t) { return new (t || NgxMasonryModule)(); };
NgxMasonryModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NgxMasonryModule });
NgxMasonryModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxMasonryModule, [{
        type: NgModule,
        args: [{
                imports: [],
                declarations: [NgxMasonryComponent, NgxMasonryDirective],
                exports: [NgxMasonryComponent, NgxMasonryDirective]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxMasonryModule, { declarations: [NgxMasonryComponent, NgxMasonryDirective], exports: [NgxMasonryComponent, NgxMasonryDirective] }); })();

/*
 * Public API Surface of ngx-masonry
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgxMasonryComponent, NgxMasonryDirective, NgxMasonryModule };

//# sourceMappingURL=ngx-masonry.js.map