import { isPlatformBrowser } from '@angular/common';
import { EventEmitter, Component, Inject, PLATFORM_ID, ElementRef, Input, Output, Directive, forwardRef, Renderer2, NgModule } from '@angular/core';
import { style, animate, AnimationBuilder } from '@angular/animations';

let masonryConstructor;
class NgxMasonryComponent {
    constructor(platformId, _element) {
        this.platformId = platformId;
        this._element = _element;
        this.updateLayout = false;
        this.ordered = false;
        // Outputs
        this.layoutComplete = new EventEmitter();
        this.removeComplete = new EventEmitter();
        this.itemsLoaded = new EventEmitter();
        this.pendingItems = [];
    }
    ngOnInit() {
        if (isPlatformBrowser(this.platformId) && masonryConstructor === undefined) {
            masonryConstructor = require('masonry-layout');
        }
        // Create masonry options object
        if (!this.options) {
            this.options = {};
        }
        // Set default itemSelector
        if (!this.options.itemSelector) {
            this.options.itemSelector = '[ngxMasonryItem], ngxMasonryItem';
        }
        this.options['transitionDuration'] = '0s';
        if (isPlatformBrowser(this.platformId)) {
            // Initialize Masonry
            this.masonryInstance = new masonryConstructor(this._element.nativeElement, this.options);
            // Bind to events
            this.masonryInstance.on('layoutComplete', (items) => {
                this.layoutComplete.emit(items);
            });
            this.masonryInstance.on('removeComplete', (items) => {
                this.removeComplete.emit(items);
            });
            this.masonryInstance.items = [];
        }
    }
    ngOnChanges(changes) {
        // only update layout if it's not the first change
        if (changes.updateLayout) {
            if (!changes.updateLayout.firstChange) {
                this.layout();
            }
        }
    }
    ngOnDestroy() {
        if (this.masonryInstance) {
            this.masonryInstance.destroy();
        }
    }
    layout() {
        setTimeout(() => {
            this.masonryInstance.layout();
        });
    }
    reloadItems() {
        setTimeout(() => {
            this.masonryInstance.reloadItems();
        });
    }
    addPendingItem(item) {
        this.pendingItems.push(item);
    }
    add(newItem) {
        if (this.ordered) {
            for (const [index, item] of this.pendingItems.entries()) {
                if (item) {
                    if (item.images && item.images.size === 0) {
                        this.pendingItems[index] = undefined;
                        this.itemLoaded(item);
                        if (index + 1 === this.pendingItems.length) {
                            // All items are loaded
                            this.itemsLoaded.emit(this.pendingItems.length);
                            this.pendingItems = [];
                        }
                    }
                    else {
                        return;
                    }
                }
            }
        }
        else {
            this.itemLoaded(newItem);
        }
    }
    itemLoaded(item) {
        if (isPlatformBrowser(this.platformId)) {
            // Tell Masonry that a child element has been added
            if (item.prepend) {
                this.masonryInstance.prepended(item.element.nativeElement);
            }
            else {
                this.masonryInstance.appended(item.element.nativeElement);
            }
            // Check if first item
            if (this.masonryInstance.items.length === 1) {
                this.masonryInstance.layout();
            }
            item.playAnimation(true);
        }
    }
    remove(element) {
        if (isPlatformBrowser(this.platformId)) {
            // Tell Masonry that a child element has been removed
            this.masonryInstance.remove(element);
            // Layout items
            this.layout();
        }
    }
}
NgxMasonryComponent.decorators = [
    { type: Component, args: [{
                selector: '[ngx-masonry], ngx-masonry',
                template: '<ng-content></ng-content>',
                styles: [`
		:host {
			display: block;
		}
	`]
            },] }
];
NgxMasonryComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: ElementRef }
];
NgxMasonryComponent.propDecorators = {
    options: [{ type: Input }],
    updateLayout: [{ type: Input }],
    ordered: [{ type: Input }],
    layoutComplete: [{ type: Output }],
    removeComplete: [{ type: Output }],
    itemsLoaded: [{ type: Output }]
};

class NgxMasonryDirective {
    constructor(element, builder, parent, renderer) {
        this.element = element;
        this.builder = builder;
        this.parent = parent;
        this.renderer = renderer;
        this.prepend = false;
        this.animations = {
            show: [
                style({ opacity: 0 }),
                animate('400ms ease-in', style({ opacity: 1 })),
            ],
            hide: [
                style({ opacity: '*' }),
                animate('400ms ease-in', style({ opacity: 0 })),
            ]
        };
    }
    ngOnInit() {
        if (this.parent.options.animations !== undefined) {
            this.animations = this.parent.options.animations;
        }
        this.renderer.setStyle(this.element.nativeElement, 'position', 'fixed');
        this.renderer.setStyle(this.element.nativeElement, 'right', '-150vw');
        this.parent.addPendingItem(this);
    }
    ngAfterViewInit() {
        const images = Array.from(this.element.nativeElement.getElementsByTagName('img'));
        this.images = new Set(images);
        if (images.length === 0) {
            setTimeout(() => {
                this.parent.add(this);
            });
        }
        else {
            for (const imageRef of images) {
                // skip image render check if image has `masonryLazy` attribute
                if (imageRef.hasAttribute('masonryLazy')) {
                    this.imageLoaded(imageRef);
                }
                else {
                    this.renderer.listen(imageRef, 'load', _ => {
                        this.imageLoaded(imageRef);
                    });
                    this.renderer.listen(imageRef, 'error', _ => {
                        this.imageLoaded(imageRef);
                    });
                }
            }
        }
    }
    ngOnDestroy() {
        if (this.images && this.images.size === 0 && this.element.nativeElement.parentNode) {
            this.playAnimation(false);
            this.parent.remove(this.element.nativeElement);
        }
    }
    imageLoaded(image) {
        this.images.delete(image);
        if (this.images.size === 0) {
            this.parent.add(this);
        }
    }
    playAnimation(show) {
        const metadata = show ? this.animations.show : this.animations.hide;
        if (metadata) {
            const player = this.builder.build(metadata).create(this.element.nativeElement);
            player.play();
        }
    }
}
NgxMasonryDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ngxMasonryItem], ngxMasonryItem'
            },] }
];
NgxMasonryDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: AnimationBuilder },
    { type: NgxMasonryComponent, decorators: [{ type: Inject, args: [forwardRef(() => NgxMasonryComponent),] }] },
    { type: Renderer2 }
];
NgxMasonryDirective.propDecorators = {
    prepend: [{ type: Input }]
};

class NgxMasonryModule {
}
NgxMasonryModule.decorators = [
    { type: NgModule, args: [{
                imports: [],
                declarations: [NgxMasonryComponent, NgxMasonryDirective],
                exports: [NgxMasonryComponent, NgxMasonryDirective]
            },] }
];

/*
 * Public API Surface of ngx-masonry
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgxMasonryComponent, NgxMasonryDirective, NgxMasonryModule };
//# sourceMappingURL=ngx-masonry.js.map
