{"ast":null,"code":"\"use strict\";\n\nvar async_1 = require('../scheduler/async');\nvar isScheduler_1 = require('../util/isScheduler');\nvar bufferTime_1 = require('../operators/bufferTime');\n/* tslint:enable:max-line-length */\n/**\r\n * Buffers the source Observable values for a specific time period.\r\n *\r\n * <span class=\"informal\">Collects values from the past as an array, and emits\r\n * those arrays periodically in time.</span>\r\n *\r\n * <img src=\"./img/bufferTime.png\" width=\"100%\">\r\n *\r\n * Buffers values from the source for a specific time duration `bufferTimeSpan`.\r\n * Unless the optional argument `bufferCreationInterval` is given, it emits and\r\n * resets the buffer every `bufferTimeSpan` milliseconds. If\r\n * `bufferCreationInterval` is given, this operator opens the buffer every\r\n * `bufferCreationInterval` milliseconds and closes (emits and resets) the\r\n * buffer every `bufferTimeSpan` milliseconds. When the optional argument\r\n * `maxBufferSize` is specified, the buffer will be closed either after\r\n * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\r\n *\r\n * @example <caption>Every second, emit an array of the recent click events</caption>\r\n * var clicks = Rx.Observable.fromEvent(document, 'click');\r\n * var buffered = clicks.bufferTime(1000);\r\n * buffered.subscribe(x => console.log(x));\r\n *\r\n * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>\r\n * var clicks = Rx.Observable.fromEvent(document, 'click');\r\n * var buffered = clicks.bufferTime(2000, 5000);\r\n * buffered.subscribe(x => console.log(x));\r\n *\r\n * @see {@link buffer}\r\n * @see {@link bufferCount}\r\n * @see {@link bufferToggle}\r\n * @see {@link bufferWhen}\r\n * @see {@link windowTime}\r\n *\r\n * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\r\n * @param {number} [bufferCreationInterval] The interval at which to start new\r\n * buffers.\r\n * @param {number} [maxBufferSize] The maximum buffer size.\r\n * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the\r\n * intervals that determine buffer boundaries.\r\n * @return {Observable<T[]>} An observable of arrays of buffered values.\r\n * @method bufferTime\r\n * @owner Observable\r\n */\nfunction bufferTime(bufferTimeSpan) {\n  var length = arguments.length;\n  var scheduler = async_1.async;\n  if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {\n    scheduler = arguments[arguments.length - 1];\n    length--;\n  }\n  var bufferCreationInterval = null;\n  if (length >= 2) {\n    bufferCreationInterval = arguments[1];\n  }\n  var maxBufferSize = Number.POSITIVE_INFINITY;\n  if (length >= 3) {\n    maxBufferSize = arguments[2];\n  }\n  return bufferTime_1.bufferTime(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler)(this);\n}\nexports.bufferTime = bufferTime;","map":{"version":3,"names":["async_1","require","isScheduler_1","bufferTime_1","bufferTime","bufferTimeSpan","length","arguments","scheduler","async","isScheduler","bufferCreationInterval","maxBufferSize","Number","POSITIVE_INFINITY","exports"],"sources":["C:/Users/HP/Desktop/4SE3/PidevSym/PiDev_Spring_Angular/Front-End/frontOffice/node_modules/ng5-slider/node_modules/rxjs/operator/bufferTime.js"],"sourcesContent":["\"use strict\";\r\nvar async_1 = require('../scheduler/async');\r\nvar isScheduler_1 = require('../util/isScheduler');\r\nvar bufferTime_1 = require('../operators/bufferTime');\r\n/* tslint:enable:max-line-length */\r\n/**\r\n * Buffers the source Observable values for a specific time period.\r\n *\r\n * <span class=\"informal\">Collects values from the past as an array, and emits\r\n * those arrays periodically in time.</span>\r\n *\r\n * <img src=\"./img/bufferTime.png\" width=\"100%\">\r\n *\r\n * Buffers values from the source for a specific time duration `bufferTimeSpan`.\r\n * Unless the optional argument `bufferCreationInterval` is given, it emits and\r\n * resets the buffer every `bufferTimeSpan` milliseconds. If\r\n * `bufferCreationInterval` is given, this operator opens the buffer every\r\n * `bufferCreationInterval` milliseconds and closes (emits and resets) the\r\n * buffer every `bufferTimeSpan` milliseconds. When the optional argument\r\n * `maxBufferSize` is specified, the buffer will be closed either after\r\n * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\r\n *\r\n * @example <caption>Every second, emit an array of the recent click events</caption>\r\n * var clicks = Rx.Observable.fromEvent(document, 'click');\r\n * var buffered = clicks.bufferTime(1000);\r\n * buffered.subscribe(x => console.log(x));\r\n *\r\n * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>\r\n * var clicks = Rx.Observable.fromEvent(document, 'click');\r\n * var buffered = clicks.bufferTime(2000, 5000);\r\n * buffered.subscribe(x => console.log(x));\r\n *\r\n * @see {@link buffer}\r\n * @see {@link bufferCount}\r\n * @see {@link bufferToggle}\r\n * @see {@link bufferWhen}\r\n * @see {@link windowTime}\r\n *\r\n * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\r\n * @param {number} [bufferCreationInterval] The interval at which to start new\r\n * buffers.\r\n * @param {number} [maxBufferSize] The maximum buffer size.\r\n * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the\r\n * intervals that determine buffer boundaries.\r\n * @return {Observable<T[]>} An observable of arrays of buffered values.\r\n * @method bufferTime\r\n * @owner Observable\r\n */\r\nfunction bufferTime(bufferTimeSpan) {\r\n    var length = arguments.length;\r\n    var scheduler = async_1.async;\r\n    if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {\r\n        scheduler = arguments[arguments.length - 1];\r\n        length--;\r\n    }\r\n    var bufferCreationInterval = null;\r\n    if (length >= 2) {\r\n        bufferCreationInterval = arguments[1];\r\n    }\r\n    var maxBufferSize = Number.POSITIVE_INFINITY;\r\n    if (length >= 3) {\r\n        maxBufferSize = arguments[2];\r\n    }\r\n    return bufferTime_1.bufferTime(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler)(this);\r\n}\r\nexports.bufferTime = bufferTime;\r\n"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,OAAO,GAAGC,OAAO,CAAC,oBAAoB,CAAC;AAC3C,IAAIC,aAAa,GAAGD,OAAO,CAAC,qBAAqB,CAAC;AAClD,IAAIE,YAAY,GAAGF,OAAO,CAAC,yBAAyB,CAAC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASG,UAAU,CAACC,cAAc,EAAE;EAChC,IAAIC,MAAM,GAAGC,SAAS,CAACD,MAAM;EAC7B,IAAIE,SAAS,GAAGR,OAAO,CAACS,KAAK;EAC7B,IAAIP,aAAa,CAACQ,WAAW,CAACH,SAAS,CAACA,SAAS,CAACD,MAAM,GAAG,CAAC,CAAC,CAAC,EAAE;IAC5DE,SAAS,GAAGD,SAAS,CAACA,SAAS,CAACD,MAAM,GAAG,CAAC,CAAC;IAC3CA,MAAM,EAAE;EACZ;EACA,IAAIK,sBAAsB,GAAG,IAAI;EACjC,IAAIL,MAAM,IAAI,CAAC,EAAE;IACbK,sBAAsB,GAAGJ,SAAS,CAAC,CAAC,CAAC;EACzC;EACA,IAAIK,aAAa,GAAGC,MAAM,CAACC,iBAAiB;EAC5C,IAAIR,MAAM,IAAI,CAAC,EAAE;IACbM,aAAa,GAAGL,SAAS,CAAC,CAAC,CAAC;EAChC;EACA,OAAOJ,YAAY,CAACC,UAAU,CAACC,cAAc,EAAEM,sBAAsB,EAAEC,aAAa,EAAEJ,SAAS,CAAC,CAAC,IAAI,CAAC;AAC1G;AACAO,OAAO,CAACX,UAAU,GAAGA,UAAU"},"metadata":{},"sourceType":"script","externalDependencies":[]}