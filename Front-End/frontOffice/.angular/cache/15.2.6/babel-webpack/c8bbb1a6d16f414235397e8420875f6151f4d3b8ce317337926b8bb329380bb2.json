{"ast":null,"code":"\"use strict\";\n\nvar async_1 = require('../scheduler/async');\nvar debounceTime_1 = require('../operators/debounceTime');\n/**\r\n * Emits a value from the source Observable only after a particular time span\r\n * has passed without another source emission.\r\n *\r\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\r\n * recent value from each burst of emissions.</span>\r\n *\r\n * <img src=\"./img/debounceTime.png\" width=\"100%\">\r\n *\r\n * `debounceTime` delays values emitted by the source Observable, but drops\r\n * previous pending delayed emissions if a new value arrives on the source\r\n * Observable. This operator keeps track of the most recent value from the\r\n * source Observable, and emits that only when `dueTime` enough time has passed\r\n * without any other value appearing on the source Observable. If a new value\r\n * appears before `dueTime` silence occurs, the previous value will be dropped\r\n * and will not be emitted on the output Observable.\r\n *\r\n * This is a rate-limiting operator, because it is impossible for more than one\r\n * value to be emitted in any time window of duration `dueTime`, but it is also\r\n * a delay-like operator since output emissions do not occur at the same time as\r\n * they did on the source Observable. Optionally takes a {@link IScheduler} for\r\n * managing timers.\r\n *\r\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\r\n * var clicks = Rx.Observable.fromEvent(document, 'click');\r\n * var result = clicks.debounceTime(1000);\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * @see {@link auditTime}\r\n * @see {@link debounce}\r\n * @see {@link delay}\r\n * @see {@link sampleTime}\r\n * @see {@link throttleTime}\r\n *\r\n * @param {number} dueTime The timeout duration in milliseconds (or the time\r\n * unit determined internally by the optional `scheduler`) for the window of\r\n * time required to wait for emission silence before emitting the most recent\r\n * source value.\r\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\r\n * managing the timers that handle the timeout for each value.\r\n * @return {Observable} An Observable that delays the emissions of the source\r\n * Observable by the specified `dueTime`, and may drop some values if they occur\r\n * too frequently.\r\n * @method debounceTime\r\n * @owner Observable\r\n */\nfunction debounceTime(dueTime, scheduler) {\n  if (scheduler === void 0) {\n    scheduler = async_1.async;\n  }\n  return debounceTime_1.debounceTime(dueTime, scheduler)(this);\n}\nexports.debounceTime = debounceTime;","map":{"version":3,"names":["async_1","require","debounceTime_1","debounceTime","dueTime","scheduler","async","exports"],"sources":["C:/Users/HP/Desktop/4SE3/PidevSym/PiDev_Spring_Angular/Front-End/frontOffice/node_modules/ng5-slider/node_modules/rxjs/operator/debounceTime.js"],"sourcesContent":["\"use strict\";\r\nvar async_1 = require('../scheduler/async');\r\nvar debounceTime_1 = require('../operators/debounceTime');\r\n/**\r\n * Emits a value from the source Observable only after a particular time span\r\n * has passed without another source emission.\r\n *\r\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\r\n * recent value from each burst of emissions.</span>\r\n *\r\n * <img src=\"./img/debounceTime.png\" width=\"100%\">\r\n *\r\n * `debounceTime` delays values emitted by the source Observable, but drops\r\n * previous pending delayed emissions if a new value arrives on the source\r\n * Observable. This operator keeps track of the most recent value from the\r\n * source Observable, and emits that only when `dueTime` enough time has passed\r\n * without any other value appearing on the source Observable. If a new value\r\n * appears before `dueTime` silence occurs, the previous value will be dropped\r\n * and will not be emitted on the output Observable.\r\n *\r\n * This is a rate-limiting operator, because it is impossible for more than one\r\n * value to be emitted in any time window of duration `dueTime`, but it is also\r\n * a delay-like operator since output emissions do not occur at the same time as\r\n * they did on the source Observable. Optionally takes a {@link IScheduler} for\r\n * managing timers.\r\n *\r\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\r\n * var clicks = Rx.Observable.fromEvent(document, 'click');\r\n * var result = clicks.debounceTime(1000);\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * @see {@link auditTime}\r\n * @see {@link debounce}\r\n * @see {@link delay}\r\n * @see {@link sampleTime}\r\n * @see {@link throttleTime}\r\n *\r\n * @param {number} dueTime The timeout duration in milliseconds (or the time\r\n * unit determined internally by the optional `scheduler`) for the window of\r\n * time required to wait for emission silence before emitting the most recent\r\n * source value.\r\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\r\n * managing the timers that handle the timeout for each value.\r\n * @return {Observable} An Observable that delays the emissions of the source\r\n * Observable by the specified `dueTime`, and may drop some values if they occur\r\n * too frequently.\r\n * @method debounceTime\r\n * @owner Observable\r\n */\r\nfunction debounceTime(dueTime, scheduler) {\r\n    if (scheduler === void 0) { scheduler = async_1.async; }\r\n    return debounceTime_1.debounceTime(dueTime, scheduler)(this);\r\n}\r\nexports.debounceTime = debounceTime;\r\n"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,OAAO,GAAGC,OAAO,CAAC,oBAAoB,CAAC;AAC3C,IAAIC,cAAc,GAAGD,OAAO,CAAC,2BAA2B,CAAC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,YAAY,CAACC,OAAO,EAAEC,SAAS,EAAE;EACtC,IAAIA,SAAS,KAAK,KAAK,CAAC,EAAE;IAAEA,SAAS,GAAGL,OAAO,CAACM,KAAK;EAAE;EACvD,OAAOJ,cAAc,CAACC,YAAY,CAACC,OAAO,EAAEC,SAAS,CAAC,CAAC,IAAI,CAAC;AAChE;AACAE,OAAO,CAACJ,YAAY,GAAGA,YAAY"},"metadata":{},"sourceType":"script","externalDependencies":[]}