{"ast":null,"code":"\"use strict\";\n\nvar catchError_1 = require('../operators/catchError');\n/**\r\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\r\n *\r\n * <img src=\"./img/catch.png\" width=\"100%\">\r\n *\r\n * @example <caption>Continues with a different Observable when there's an error</caption>\r\n *\r\n * Observable.of(1, 2, 3, 4, 5)\r\n *   .map(n => {\r\n * \t   if (n == 4) {\r\n * \t     throw 'four!';\r\n *     }\r\n *\t   return n;\r\n *   })\r\n *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))\r\n *   .subscribe(x => console.log(x));\r\n *   // 1, 2, 3, I, II, III, IV, V\r\n *\r\n * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>\r\n *\r\n * Observable.of(1, 2, 3, 4, 5)\r\n *   .map(n => {\r\n * \t   if (n === 4) {\r\n * \t     throw 'four!';\r\n *     }\r\n * \t   return n;\r\n *   })\r\n *   .catch((err, caught) => caught)\r\n *   .take(30)\r\n *   .subscribe(x => console.log(x));\r\n *   // 1, 2, 3, 1, 2, 3, ...\r\n *\r\n * @example <caption>Throws a new error when the source Observable throws an error</caption>\r\n *\r\n * Observable.of(1, 2, 3, 4, 5)\r\n *   .map(n => {\r\n *     if (n == 4) {\r\n *       throw 'four!';\r\n *     }\r\n *     return n;\r\n *   })\r\n *   .catch(err => {\r\n *     throw 'error in source. Details: ' + err;\r\n *   })\r\n *   .subscribe(\r\n *     x => console.log(x),\r\n *     err => console.log(err)\r\n *   );\r\n *   // 1, 2, 3, error in source. Details: four!\r\n *\r\n * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\r\n *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\r\n *  is returned by the `selector` will be used to continue the observable chain.\r\n * @return {Observable} An observable that originates from either the source or the observable returned by the\r\n *  catch `selector` function.\r\n * @method catch\r\n * @name catch\r\n * @owner Observable\r\n */\nfunction _catch(selector) {\n  return catchError_1.catchError(selector)(this);\n}\nexports._catch = _catch;","map":{"version":3,"names":["catchError_1","require","_catch","selector","catchError","exports"],"sources":["C:/Users/HP/Desktop/4SE3/PidevSym/PiDev_Spring_Angular/Front-End/frontOffice/node_modules/ng5-slider/node_modules/rxjs/operator/catch.js"],"sourcesContent":["\"use strict\";\r\nvar catchError_1 = require('../operators/catchError');\r\n/**\r\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\r\n *\r\n * <img src=\"./img/catch.png\" width=\"100%\">\r\n *\r\n * @example <caption>Continues with a different Observable when there's an error</caption>\r\n *\r\n * Observable.of(1, 2, 3, 4, 5)\r\n *   .map(n => {\r\n * \t   if (n == 4) {\r\n * \t     throw 'four!';\r\n *     }\r\n *\t   return n;\r\n *   })\r\n *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))\r\n *   .subscribe(x => console.log(x));\r\n *   // 1, 2, 3, I, II, III, IV, V\r\n *\r\n * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>\r\n *\r\n * Observable.of(1, 2, 3, 4, 5)\r\n *   .map(n => {\r\n * \t   if (n === 4) {\r\n * \t     throw 'four!';\r\n *     }\r\n * \t   return n;\r\n *   })\r\n *   .catch((err, caught) => caught)\r\n *   .take(30)\r\n *   .subscribe(x => console.log(x));\r\n *   // 1, 2, 3, 1, 2, 3, ...\r\n *\r\n * @example <caption>Throws a new error when the source Observable throws an error</caption>\r\n *\r\n * Observable.of(1, 2, 3, 4, 5)\r\n *   .map(n => {\r\n *     if (n == 4) {\r\n *       throw 'four!';\r\n *     }\r\n *     return n;\r\n *   })\r\n *   .catch(err => {\r\n *     throw 'error in source. Details: ' + err;\r\n *   })\r\n *   .subscribe(\r\n *     x => console.log(x),\r\n *     err => console.log(err)\r\n *   );\r\n *   // 1, 2, 3, error in source. Details: four!\r\n *\r\n * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\r\n *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\r\n *  is returned by the `selector` will be used to continue the observable chain.\r\n * @return {Observable} An observable that originates from either the source or the observable returned by the\r\n *  catch `selector` function.\r\n * @method catch\r\n * @name catch\r\n * @owner Observable\r\n */\r\nfunction _catch(selector) {\r\n    return catchError_1.catchError(selector)(this);\r\n}\r\nexports._catch = _catch;\r\n"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,YAAY,GAAGC,OAAO,CAAC,yBAAyB,CAAC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,MAAM,CAACC,QAAQ,EAAE;EACtB,OAAOH,YAAY,CAACI,UAAU,CAACD,QAAQ,CAAC,CAAC,IAAI,CAAC;AAClD;AACAE,OAAO,CAACH,MAAM,GAAGA,MAAM"},"metadata":{},"sourceType":"script","externalDependencies":[]}