{"ast":null,"code":"\"use strict\";\n\nvar exhaustMap_1 = require('../operators/exhaustMap');\n/* tslint:enable:max-line-length */\n/**\r\n * Projects each source value to an Observable which is merged in the output\r\n * Observable only if the previous projected Observable has completed.\r\n *\r\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\r\n * these inner Observables using {@link exhaust}.</span>\r\n *\r\n * <img src=\"./img/exhaustMap.png\" width=\"100%\">\r\n *\r\n * Returns an Observable that emits items based on applying a function that you\r\n * supply to each item emitted by the source Observable, where that function\r\n * returns an (so-called \"inner\") Observable. When it projects a source value to\r\n * an Observable, the output Observable begins emitting the items emitted by\r\n * that projected Observable. However, `exhaustMap` ignores every new projected\r\n * Observable if the previous projected Observable has not yet completed. Once\r\n * that one completes, it will accept and flatten the next projected Observable\r\n * and repeat this process.\r\n *\r\n * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\r\n * var clicks = Rx.Observable.fromEvent(document, 'click');\r\n * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000).take(5));\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * @see {@link concatMap}\r\n * @see {@link exhaust}\r\n * @see {@link mergeMap}\r\n * @see {@link switchMap}\r\n *\r\n * @param {function(value: T, ?index: number): ObservableInput} project A function\r\n * that, when applied to an item emitted by the source Observable, returns an\r\n * Observable.\r\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\r\n * A function to produce the value on the output Observable based on the values\r\n * and the indices of the source (outer) emission and the inner Observable\r\n * emission. The arguments passed to this function are:\r\n * - `outerValue`: the value that came from the source\r\n * - `innerValue`: the value that came from the projected Observable\r\n * - `outerIndex`: the \"index\" of the value that came from the source\r\n * - `innerIndex`: the \"index\" of the value from the projected Observable\r\n * @return {Observable} An Observable containing projected Observables\r\n * of each item of the source, ignoring projected Observables that start before\r\n * their preceding Observable has completed.\r\n * @method exhaustMap\r\n * @owner Observable\r\n */\nfunction exhaustMap(project, resultSelector) {\n  return exhaustMap_1.exhaustMap(project, resultSelector)(this);\n}\nexports.exhaustMap = exhaustMap;","map":{"version":3,"names":["exhaustMap_1","require","exhaustMap","project","resultSelector","exports"],"sources":["C:/Users/HP/Desktop/4SE3/PidevSym/PiDev_Spring_Angular/Front-End/frontOffice/node_modules/ng5-slider/node_modules/rxjs/operator/exhaustMap.js"],"sourcesContent":["\"use strict\";\r\nvar exhaustMap_1 = require('../operators/exhaustMap');\r\n/* tslint:enable:max-line-length */\r\n/**\r\n * Projects each source value to an Observable which is merged in the output\r\n * Observable only if the previous projected Observable has completed.\r\n *\r\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\r\n * these inner Observables using {@link exhaust}.</span>\r\n *\r\n * <img src=\"./img/exhaustMap.png\" width=\"100%\">\r\n *\r\n * Returns an Observable that emits items based on applying a function that you\r\n * supply to each item emitted by the source Observable, where that function\r\n * returns an (so-called \"inner\") Observable. When it projects a source value to\r\n * an Observable, the output Observable begins emitting the items emitted by\r\n * that projected Observable. However, `exhaustMap` ignores every new projected\r\n * Observable if the previous projected Observable has not yet completed. Once\r\n * that one completes, it will accept and flatten the next projected Observable\r\n * and repeat this process.\r\n *\r\n * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\r\n * var clicks = Rx.Observable.fromEvent(document, 'click');\r\n * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000).take(5));\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * @see {@link concatMap}\r\n * @see {@link exhaust}\r\n * @see {@link mergeMap}\r\n * @see {@link switchMap}\r\n *\r\n * @param {function(value: T, ?index: number): ObservableInput} project A function\r\n * that, when applied to an item emitted by the source Observable, returns an\r\n * Observable.\r\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\r\n * A function to produce the value on the output Observable based on the values\r\n * and the indices of the source (outer) emission and the inner Observable\r\n * emission. The arguments passed to this function are:\r\n * - `outerValue`: the value that came from the source\r\n * - `innerValue`: the value that came from the projected Observable\r\n * - `outerIndex`: the \"index\" of the value that came from the source\r\n * - `innerIndex`: the \"index\" of the value from the projected Observable\r\n * @return {Observable} An Observable containing projected Observables\r\n * of each item of the source, ignoring projected Observables that start before\r\n * their preceding Observable has completed.\r\n * @method exhaustMap\r\n * @owner Observable\r\n */\r\nfunction exhaustMap(project, resultSelector) {\r\n    return exhaustMap_1.exhaustMap(project, resultSelector)(this);\r\n}\r\nexports.exhaustMap = exhaustMap;\r\n"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,YAAY,GAAGC,OAAO,CAAC,yBAAyB,CAAC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,UAAU,CAACC,OAAO,EAAEC,cAAc,EAAE;EACzC,OAAOJ,YAAY,CAACE,UAAU,CAACC,OAAO,EAAEC,cAAc,CAAC,CAAC,IAAI,CAAC;AACjE;AACAC,OAAO,CAACH,UAAU,GAAGA,UAAU"},"metadata":{},"sourceType":"script","externalDependencies":[]}