{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = require('../scheduler/async');\nvar Subscriber_1 = require('../Subscriber');\nvar isScheduler_1 = require('../util/isScheduler');\n/* tslint:enable:max-line-length */\n/**\r\n * Buffers the source Observable values for a specific time period.\r\n *\r\n * <span class=\"informal\">Collects values from the past as an array, and emits\r\n * those arrays periodically in time.</span>\r\n *\r\n * <img src=\"./img/bufferTime.png\" width=\"100%\">\r\n *\r\n * Buffers values from the source for a specific time duration `bufferTimeSpan`.\r\n * Unless the optional argument `bufferCreationInterval` is given, it emits and\r\n * resets the buffer every `bufferTimeSpan` milliseconds. If\r\n * `bufferCreationInterval` is given, this operator opens the buffer every\r\n * `bufferCreationInterval` milliseconds and closes (emits and resets) the\r\n * buffer every `bufferTimeSpan` milliseconds. When the optional argument\r\n * `maxBufferSize` is specified, the buffer will be closed either after\r\n * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\r\n *\r\n * @example <caption>Every second, emit an array of the recent click events</caption>\r\n * var clicks = Rx.Observable.fromEvent(document, 'click');\r\n * var buffered = clicks.bufferTime(1000);\r\n * buffered.subscribe(x => console.log(x));\r\n *\r\n * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>\r\n * var clicks = Rx.Observable.fromEvent(document, 'click');\r\n * var buffered = clicks.bufferTime(2000, 5000);\r\n * buffered.subscribe(x => console.log(x));\r\n *\r\n * @see {@link buffer}\r\n * @see {@link bufferCount}\r\n * @see {@link bufferToggle}\r\n * @see {@link bufferWhen}\r\n * @see {@link windowTime}\r\n *\r\n * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\r\n * @param {number} [bufferCreationInterval] The interval at which to start new\r\n * buffers.\r\n * @param {number} [maxBufferSize] The maximum buffer size.\r\n * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the\r\n * intervals that determine buffer boundaries.\r\n * @return {Observable<T[]>} An observable of arrays of buffered values.\r\n * @method bufferTime\r\n * @owner Observable\r\n */\nfunction bufferTime(bufferTimeSpan) {\n  var length = arguments.length;\n  var scheduler = async_1.async;\n  if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {\n    scheduler = arguments[arguments.length - 1];\n    length--;\n  }\n  var bufferCreationInterval = null;\n  if (length >= 2) {\n    bufferCreationInterval = arguments[1];\n  }\n  var maxBufferSize = Number.POSITIVE_INFINITY;\n  if (length >= 3) {\n    maxBufferSize = arguments[2];\n  }\n  return function bufferTimeOperatorFunction(source) {\n    return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n  };\n}\nexports.bufferTime = bufferTime;\nvar BufferTimeOperator = function () {\n  function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n    this.bufferTimeSpan = bufferTimeSpan;\n    this.bufferCreationInterval = bufferCreationInterval;\n    this.maxBufferSize = maxBufferSize;\n    this.scheduler = scheduler;\n  }\n  BufferTimeOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));\n  };\n  return BufferTimeOperator;\n}();\nvar Context = function () {\n  function Context() {\n    this.buffer = [];\n  }\n  return Context;\n}();\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\nvar BufferTimeSubscriber = function (_super) {\n  __extends(BufferTimeSubscriber, _super);\n  function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n    _super.call(this, destination);\n    this.bufferTimeSpan = bufferTimeSpan;\n    this.bufferCreationInterval = bufferCreationInterval;\n    this.maxBufferSize = maxBufferSize;\n    this.scheduler = scheduler;\n    this.contexts = [];\n    var context = this.openContext();\n    this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n    if (this.timespanOnly) {\n      var timeSpanOnlyState = {\n        subscriber: this,\n        context: context,\n        bufferTimeSpan: bufferTimeSpan\n      };\n      this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    } else {\n      var closeState = {\n        subscriber: this,\n        context: context\n      };\n      var creationState = {\n        bufferTimeSpan: bufferTimeSpan,\n        bufferCreationInterval: bufferCreationInterval,\n        subscriber: this,\n        scheduler: scheduler\n      };\n      this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\n      this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\n    }\n  }\n  BufferTimeSubscriber.prototype._next = function (value) {\n    var contexts = this.contexts;\n    var len = contexts.length;\n    var filledBufferContext;\n    for (var i = 0; i < len; i++) {\n      var context = contexts[i];\n      var buffer = context.buffer;\n      buffer.push(value);\n      if (buffer.length == this.maxBufferSize) {\n        filledBufferContext = context;\n      }\n    }\n    if (filledBufferContext) {\n      this.onBufferFull(filledBufferContext);\n    }\n  };\n  BufferTimeSubscriber.prototype._error = function (err) {\n    this.contexts.length = 0;\n    _super.prototype._error.call(this, err);\n  };\n  BufferTimeSubscriber.prototype._complete = function () {\n    var _a = this,\n      contexts = _a.contexts,\n      destination = _a.destination;\n    while (contexts.length > 0) {\n      var context = contexts.shift();\n      destination.next(context.buffer);\n    }\n    _super.prototype._complete.call(this);\n  };\n  /** @deprecated internal use only */\n  BufferTimeSubscriber.prototype._unsubscribe = function () {\n    this.contexts = null;\n  };\n  BufferTimeSubscriber.prototype.onBufferFull = function (context) {\n    this.closeContext(context);\n    var closeAction = context.closeAction;\n    closeAction.unsubscribe();\n    this.remove(closeAction);\n    if (!this.closed && this.timespanOnly) {\n      context = this.openContext();\n      var bufferTimeSpan = this.bufferTimeSpan;\n      var timeSpanOnlyState = {\n        subscriber: this,\n        context: context,\n        bufferTimeSpan: bufferTimeSpan\n      };\n      this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    }\n  };\n  BufferTimeSubscriber.prototype.openContext = function () {\n    var context = new Context();\n    this.contexts.push(context);\n    return context;\n  };\n  BufferTimeSubscriber.prototype.closeContext = function (context) {\n    this.destination.next(context.buffer);\n    var contexts = this.contexts;\n    var spliceIndex = contexts ? contexts.indexOf(context) : -1;\n    if (spliceIndex >= 0) {\n      contexts.splice(contexts.indexOf(context), 1);\n    }\n  };\n  return BufferTimeSubscriber;\n}(Subscriber_1.Subscriber);\nfunction dispatchBufferTimeSpanOnly(state) {\n  var subscriber = state.subscriber;\n  var prevContext = state.context;\n  if (prevContext) {\n    subscriber.closeContext(prevContext);\n  }\n  if (!subscriber.closed) {\n    state.context = subscriber.openContext();\n    state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n  }\n}\nfunction dispatchBufferCreation(state) {\n  var bufferCreationInterval = state.bufferCreationInterval,\n    bufferTimeSpan = state.bufferTimeSpan,\n    subscriber = state.subscriber,\n    scheduler = state.scheduler;\n  var context = subscriber.openContext();\n  var action = this;\n  if (!subscriber.closed) {\n    subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, {\n      subscriber: subscriber,\n      context: context\n    }));\n    action.schedule(state, bufferCreationInterval);\n  }\n}\nfunction dispatchBufferClose(arg) {\n  var subscriber = arg.subscriber,\n    context = arg.context;\n  subscriber.closeContext(context);\n}","map":{"version":3,"names":["__extends","d","b","p","hasOwnProperty","__","constructor","prototype","Object","create","async_1","require","Subscriber_1","isScheduler_1","bufferTime","bufferTimeSpan","length","arguments","scheduler","async","isScheduler","bufferCreationInterval","maxBufferSize","Number","POSITIVE_INFINITY","bufferTimeOperatorFunction","source","lift","BufferTimeOperator","exports","call","subscriber","subscribe","BufferTimeSubscriber","Context","buffer","_super","destination","contexts","context","openContext","timespanOnly","timeSpanOnlyState","add","closeAction","schedule","dispatchBufferTimeSpanOnly","closeState","creationState","dispatchBufferClose","dispatchBufferCreation","_next","value","len","filledBufferContext","i","push","onBufferFull","_error","err","_complete","_a","shift","next","_unsubscribe","closeContext","unsubscribe","remove","closed","spliceIndex","indexOf","splice","Subscriber","state","prevContext","action","arg"],"sources":["C:/Users/HP/Desktop/4SE3/PidevSym/PiDev_Spring_Angular/Front-End/frontOffice/node_modules/ng5-slider/node_modules/rxjs/operators/bufferTime.js"],"sourcesContent":["\"use strict\";\r\nvar __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar async_1 = require('../scheduler/async');\r\nvar Subscriber_1 = require('../Subscriber');\r\nvar isScheduler_1 = require('../util/isScheduler');\r\n/* tslint:enable:max-line-length */\r\n/**\r\n * Buffers the source Observable values for a specific time period.\r\n *\r\n * <span class=\"informal\">Collects values from the past as an array, and emits\r\n * those arrays periodically in time.</span>\r\n *\r\n * <img src=\"./img/bufferTime.png\" width=\"100%\">\r\n *\r\n * Buffers values from the source for a specific time duration `bufferTimeSpan`.\r\n * Unless the optional argument `bufferCreationInterval` is given, it emits and\r\n * resets the buffer every `bufferTimeSpan` milliseconds. If\r\n * `bufferCreationInterval` is given, this operator opens the buffer every\r\n * `bufferCreationInterval` milliseconds and closes (emits and resets) the\r\n * buffer every `bufferTimeSpan` milliseconds. When the optional argument\r\n * `maxBufferSize` is specified, the buffer will be closed either after\r\n * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\r\n *\r\n * @example <caption>Every second, emit an array of the recent click events</caption>\r\n * var clicks = Rx.Observable.fromEvent(document, 'click');\r\n * var buffered = clicks.bufferTime(1000);\r\n * buffered.subscribe(x => console.log(x));\r\n *\r\n * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>\r\n * var clicks = Rx.Observable.fromEvent(document, 'click');\r\n * var buffered = clicks.bufferTime(2000, 5000);\r\n * buffered.subscribe(x => console.log(x));\r\n *\r\n * @see {@link buffer}\r\n * @see {@link bufferCount}\r\n * @see {@link bufferToggle}\r\n * @see {@link bufferWhen}\r\n * @see {@link windowTime}\r\n *\r\n * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\r\n * @param {number} [bufferCreationInterval] The interval at which to start new\r\n * buffers.\r\n * @param {number} [maxBufferSize] The maximum buffer size.\r\n * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the\r\n * intervals that determine buffer boundaries.\r\n * @return {Observable<T[]>} An observable of arrays of buffered values.\r\n * @method bufferTime\r\n * @owner Observable\r\n */\r\nfunction bufferTime(bufferTimeSpan) {\r\n    var length = arguments.length;\r\n    var scheduler = async_1.async;\r\n    if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {\r\n        scheduler = arguments[arguments.length - 1];\r\n        length--;\r\n    }\r\n    var bufferCreationInterval = null;\r\n    if (length >= 2) {\r\n        bufferCreationInterval = arguments[1];\r\n    }\r\n    var maxBufferSize = Number.POSITIVE_INFINITY;\r\n    if (length >= 3) {\r\n        maxBufferSize = arguments[2];\r\n    }\r\n    return function bufferTimeOperatorFunction(source) {\r\n        return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\r\n    };\r\n}\r\nexports.bufferTime = bufferTime;\r\nvar BufferTimeOperator = (function () {\r\n    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\r\n        this.bufferTimeSpan = bufferTimeSpan;\r\n        this.bufferCreationInterval = bufferCreationInterval;\r\n        this.maxBufferSize = maxBufferSize;\r\n        this.scheduler = scheduler;\r\n    }\r\n    BufferTimeOperator.prototype.call = function (subscriber, source) {\r\n        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));\r\n    };\r\n    return BufferTimeOperator;\r\n}());\r\nvar Context = (function () {\r\n    function Context() {\r\n        this.buffer = [];\r\n    }\r\n    return Context;\r\n}());\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nvar BufferTimeSubscriber = (function (_super) {\r\n    __extends(BufferTimeSubscriber, _super);\r\n    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\r\n        _super.call(this, destination);\r\n        this.bufferTimeSpan = bufferTimeSpan;\r\n        this.bufferCreationInterval = bufferCreationInterval;\r\n        this.maxBufferSize = maxBufferSize;\r\n        this.scheduler = scheduler;\r\n        this.contexts = [];\r\n        var context = this.openContext();\r\n        this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\r\n        if (this.timespanOnly) {\r\n            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };\r\n            this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\r\n        }\r\n        else {\r\n            var closeState = { subscriber: this, context: context };\r\n            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: this, scheduler: scheduler };\r\n            this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\r\n            this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\r\n        }\r\n    }\r\n    BufferTimeSubscriber.prototype._next = function (value) {\r\n        var contexts = this.contexts;\r\n        var len = contexts.length;\r\n        var filledBufferContext;\r\n        for (var i = 0; i < len; i++) {\r\n            var context = contexts[i];\r\n            var buffer = context.buffer;\r\n            buffer.push(value);\r\n            if (buffer.length == this.maxBufferSize) {\r\n                filledBufferContext = context;\r\n            }\r\n        }\r\n        if (filledBufferContext) {\r\n            this.onBufferFull(filledBufferContext);\r\n        }\r\n    };\r\n    BufferTimeSubscriber.prototype._error = function (err) {\r\n        this.contexts.length = 0;\r\n        _super.prototype._error.call(this, err);\r\n    };\r\n    BufferTimeSubscriber.prototype._complete = function () {\r\n        var _a = this, contexts = _a.contexts, destination = _a.destination;\r\n        while (contexts.length > 0) {\r\n            var context = contexts.shift();\r\n            destination.next(context.buffer);\r\n        }\r\n        _super.prototype._complete.call(this);\r\n    };\r\n    /** @deprecated internal use only */ BufferTimeSubscriber.prototype._unsubscribe = function () {\r\n        this.contexts = null;\r\n    };\r\n    BufferTimeSubscriber.prototype.onBufferFull = function (context) {\r\n        this.closeContext(context);\r\n        var closeAction = context.closeAction;\r\n        closeAction.unsubscribe();\r\n        this.remove(closeAction);\r\n        if (!this.closed && this.timespanOnly) {\r\n            context = this.openContext();\r\n            var bufferTimeSpan = this.bufferTimeSpan;\r\n            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };\r\n            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\r\n        }\r\n    };\r\n    BufferTimeSubscriber.prototype.openContext = function () {\r\n        var context = new Context();\r\n        this.contexts.push(context);\r\n        return context;\r\n    };\r\n    BufferTimeSubscriber.prototype.closeContext = function (context) {\r\n        this.destination.next(context.buffer);\r\n        var contexts = this.contexts;\r\n        var spliceIndex = contexts ? contexts.indexOf(context) : -1;\r\n        if (spliceIndex >= 0) {\r\n            contexts.splice(contexts.indexOf(context), 1);\r\n        }\r\n    };\r\n    return BufferTimeSubscriber;\r\n}(Subscriber_1.Subscriber));\r\nfunction dispatchBufferTimeSpanOnly(state) {\r\n    var subscriber = state.subscriber;\r\n    var prevContext = state.context;\r\n    if (prevContext) {\r\n        subscriber.closeContext(prevContext);\r\n    }\r\n    if (!subscriber.closed) {\r\n        state.context = subscriber.openContext();\r\n        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\r\n    }\r\n}\r\nfunction dispatchBufferCreation(state) {\r\n    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;\r\n    var context = subscriber.openContext();\r\n    var action = this;\r\n    if (!subscriber.closed) {\r\n        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));\r\n        action.schedule(state, bufferCreationInterval);\r\n    }\r\n}\r\nfunction dispatchBufferClose(arg) {\r\n    var subscriber = arg.subscriber, context = arg.context;\r\n    subscriber.closeContext(context);\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}