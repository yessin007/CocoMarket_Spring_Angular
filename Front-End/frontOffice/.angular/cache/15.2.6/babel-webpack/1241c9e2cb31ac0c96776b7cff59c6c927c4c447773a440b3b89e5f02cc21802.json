{"ast":null,"code":"\"use strict\";\n\nvar mergeMapTo_1 = require('../operators/mergeMapTo');\n/* tslint:enable:max-line-length */\n/**\r\n * Projects each source value to the same Observable which is merged multiple\r\n * times in the output Observable.\r\n *\r\n * <span class=\"informal\">It's like {@link mergeMap}, but maps each value always\r\n * to the same inner Observable.</span>\r\n *\r\n * <img src=\"./img/mergeMapTo.png\" width=\"100%\">\r\n *\r\n * Maps each source value to the given Observable `innerObservable` regardless\r\n * of the source value, and then merges those resulting Observables into one\r\n * single Observable, which is the output Observable.\r\n *\r\n * @example <caption>For each click event, start an interval Observable ticking every 1 second</caption>\r\n * var clicks = Rx.Observable.fromEvent(document, 'click');\r\n * var result = clicks.mergeMapTo(Rx.Observable.interval(1000));\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * @see {@link concatMapTo}\r\n * @see {@link merge}\r\n * @see {@link mergeAll}\r\n * @see {@link mergeMap}\r\n * @see {@link mergeScan}\r\n * @see {@link switchMapTo}\r\n *\r\n * @param {ObservableInput} innerObservable An Observable to replace each value from\r\n * the source Observable.\r\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\r\n * A function to produce the value on the output Observable based on the values\r\n * and the indices of the source (outer) emission and the inner Observable\r\n * emission. The arguments passed to this function are:\r\n * - `outerValue`: the value that came from the source\r\n * - `innerValue`: the value that came from the projected Observable\r\n * - `outerIndex`: the \"index\" of the value that came from the source\r\n * - `innerIndex`: the \"index\" of the value from the projected Observable\r\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\r\n * Observables being subscribed to concurrently.\r\n * @return {Observable} An Observable that emits items from the given\r\n * `innerObservable` (and optionally transformed through `resultSelector`) every\r\n * time a value is emitted on the source Observable.\r\n * @method mergeMapTo\r\n * @owner Observable\r\n */\nfunction mergeMapTo(innerObservable, resultSelector, concurrent) {\n  if (concurrent === void 0) {\n    concurrent = Number.POSITIVE_INFINITY;\n  }\n  return mergeMapTo_1.mergeMapTo(innerObservable, resultSelector, concurrent)(this);\n}\nexports.mergeMapTo = mergeMapTo;","map":{"version":3,"names":["mergeMapTo_1","require","mergeMapTo","innerObservable","resultSelector","concurrent","Number","POSITIVE_INFINITY","exports"],"sources":["C:/Users/HP/Desktop/4SE3/PidevSym/PiDev_Spring_Angular/Front-End/frontOffice/node_modules/ng5-slider/node_modules/rxjs/operator/mergeMapTo.js"],"sourcesContent":["\"use strict\";\r\nvar mergeMapTo_1 = require('../operators/mergeMapTo');\r\n/* tslint:enable:max-line-length */\r\n/**\r\n * Projects each source value to the same Observable which is merged multiple\r\n * times in the output Observable.\r\n *\r\n * <span class=\"informal\">It's like {@link mergeMap}, but maps each value always\r\n * to the same inner Observable.</span>\r\n *\r\n * <img src=\"./img/mergeMapTo.png\" width=\"100%\">\r\n *\r\n * Maps each source value to the given Observable `innerObservable` regardless\r\n * of the source value, and then merges those resulting Observables into one\r\n * single Observable, which is the output Observable.\r\n *\r\n * @example <caption>For each click event, start an interval Observable ticking every 1 second</caption>\r\n * var clicks = Rx.Observable.fromEvent(document, 'click');\r\n * var result = clicks.mergeMapTo(Rx.Observable.interval(1000));\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * @see {@link concatMapTo}\r\n * @see {@link merge}\r\n * @see {@link mergeAll}\r\n * @see {@link mergeMap}\r\n * @see {@link mergeScan}\r\n * @see {@link switchMapTo}\r\n *\r\n * @param {ObservableInput} innerObservable An Observable to replace each value from\r\n * the source Observable.\r\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\r\n * A function to produce the value on the output Observable based on the values\r\n * and the indices of the source (outer) emission and the inner Observable\r\n * emission. The arguments passed to this function are:\r\n * - `outerValue`: the value that came from the source\r\n * - `innerValue`: the value that came from the projected Observable\r\n * - `outerIndex`: the \"index\" of the value that came from the source\r\n * - `innerIndex`: the \"index\" of the value from the projected Observable\r\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\r\n * Observables being subscribed to concurrently.\r\n * @return {Observable} An Observable that emits items from the given\r\n * `innerObservable` (and optionally transformed through `resultSelector`) every\r\n * time a value is emitted on the source Observable.\r\n * @method mergeMapTo\r\n * @owner Observable\r\n */\r\nfunction mergeMapTo(innerObservable, resultSelector, concurrent) {\r\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\r\n    return mergeMapTo_1.mergeMapTo(innerObservable, resultSelector, concurrent)(this);\r\n}\r\nexports.mergeMapTo = mergeMapTo;\r\n"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,YAAY,GAAGC,OAAO,CAAC,yBAAyB,CAAC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,UAAU,CAACC,eAAe,EAAEC,cAAc,EAAEC,UAAU,EAAE;EAC7D,IAAIA,UAAU,KAAK,KAAK,CAAC,EAAE;IAAEA,UAAU,GAAGC,MAAM,CAACC,iBAAiB;EAAE;EACpE,OAAOP,YAAY,CAACE,UAAU,CAACC,eAAe,EAAEC,cAAc,EAAEC,UAAU,CAAC,CAAC,IAAI,CAAC;AACrF;AACAG,OAAO,CAACN,UAAU,GAAGA,UAAU"},"metadata":{},"sourceType":"script","externalDependencies":[]}