{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar EmptyObservable_1 = require('./EmptyObservable');\nvar isArray_1 = require('../util/isArray');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @extends {Ignored}\r\n * @hide true\r\n */\nvar ForkJoinObservable = function (_super) {\n  __extends(ForkJoinObservable, _super);\n  function ForkJoinObservable(sources, resultSelector) {\n    _super.call(this);\n    this.sources = sources;\n    this.resultSelector = resultSelector;\n  }\n  /* tslint:enable:max-line-length */\n  /**\r\n   * Joins last values emitted by passed Observables.\r\n   *\r\n   * <span class=\"informal\">Wait for Observables to complete and then combine last values they emitted.</span>\r\n   *\r\n   * <img src=\"./img/forkJoin.png\" width=\"100%\">\r\n   *\r\n   * `forkJoin` is an operator that takes any number of Observables which can be passed either as an array\r\n   * or directly as arguments. If no input Observables are provided, resulting stream will complete\r\n   * immediately.\r\n   *\r\n   * `forkJoin` will wait for all passed Observables to complete and then it will emit an array with last\r\n   * values from corresponding Observables. So if you pass `n` Observables to the operator, resulting\r\n   * array will have `n` values, where first value is the last thing emitted by the first Observable,\r\n   * second value is the last thing emitted by the second Observable and so on. That means `forkJoin` will\r\n   * not emit more than once and it will complete after that. If you need to emit combined values not only\r\n   * at the end of lifecycle of passed Observables, but also throughout it, try out {@link combineLatest}\r\n   * or {@link zip} instead.\r\n   *\r\n   * In order for resulting array to have the same length as the number of input Observables, whenever any of\r\n   * that Observables completes without emitting any value, `forkJoin` will complete at that moment as well\r\n   * and it will not emit anything either, even if it already has some last values from other Observables.\r\n   * Conversely, if there is an Observable that never completes, `forkJoin` will never complete as well,\r\n   * unless at any point some other Observable completes without emitting value, which brings us back to\r\n   * the previous case. Overall, in order for `forkJoin` to emit a value, all Observables passed as arguments\r\n   * have to emit something at least once and complete.\r\n   *\r\n   * If any input Observable errors at some point, `forkJoin` will error as well and all other Observables\r\n   * will be immediately unsubscribed.\r\n   *\r\n   * Optionally `forkJoin` accepts project function, that will be called with values which normally\r\n   * would land in emitted array. Whatever is returned by project function, will appear in output\r\n   * Observable instead. This means that default project can be thought of as a function that takes\r\n   * all its arguments and puts them into an array. Note that project function will be called only\r\n   * when output Observable is supposed to emit a result.\r\n   *\r\n   * @example <caption>Use forkJoin with operator emitting immediately</caption>\r\n   * const observable = Rx.Observable.forkJoin(\r\n   *   Rx.Observable.of(1, 2, 3, 4),\r\n   *   Rx.Observable.of(5, 6, 7, 8)\r\n   * );\r\n   * observable.subscribe(\r\n   *   value => console.log(value),\r\n   *   err => {},\r\n   *   () => console.log('This is how it ends!')\r\n   * );\r\n   *\r\n   * // Logs:\r\n   * // [4, 8]\r\n   * // \"This is how it ends!\"\r\n   *\r\n   *\r\n   * @example <caption>Use forkJoin with operator emitting after some time</caption>\r\n   * const observable = Rx.Observable.forkJoin(\r\n   *   Rx.Observable.interval(1000).take(3), // emit 0, 1, 2 every second and complete\r\n   *   Rx.Observable.interval(500).take(4) // emit 0, 1, 2, 3 every half a second and complete\r\n   * );\r\n   * observable.subscribe(\r\n   *   value => console.log(value),\r\n   *   err => {},\r\n   *   () => console.log('This is how it ends!')\r\n   * );\r\n   *\r\n   * // Logs:\r\n   * // [2, 3] after 3 seconds\r\n   * // \"This is how it ends!\" immediately after\r\n   *\r\n   *\r\n   * @example <caption>Use forkJoin with project function</caption>\r\n   * const observable = Rx.Observable.forkJoin(\r\n   *   Rx.Observable.interval(1000).take(3), // emit 0, 1, 2 every second and complete\r\n   *   Rx.Observable.interval(500).take(4), // emit 0, 1, 2, 3 every half a second and complete\r\n   *   (n, m) => n + m\r\n   * );\r\n   * observable.subscribe(\r\n   *   value => console.log(value),\r\n   *   err => {},\r\n   *   () => console.log('This is how it ends!')\r\n   * );\r\n   *\r\n   * // Logs:\r\n   * // 5 after 3 seconds\r\n   * // \"This is how it ends!\" immediately after\r\n   *\r\n   * @see {@link combineLatest}\r\n   * @see {@link zip}\r\n   *\r\n   * @param {...SubscribableOrPromise} sources Any number of Observables provided either as an array or as an arguments\r\n   * passed directly to the operator.\r\n   * @param {function} [project] Function that takes values emitted by input Observables and returns value\r\n   * that will appear in resulting Observable instead of default array.\r\n   * @return {Observable} Observable emitting either an array of last values emitted by passed Observables\r\n   * or value from project function.\r\n   * @static true\r\n   * @name forkJoin\r\n   * @owner Observable\r\n   */\n  ForkJoinObservable.create = function () {\n    var sources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      sources[_i - 0] = arguments[_i];\n    }\n    if (sources === null || arguments.length === 0) {\n      return new EmptyObservable_1.EmptyObservable();\n    }\n    var resultSelector = null;\n    if (typeof sources[sources.length - 1] === 'function') {\n      resultSelector = sources.pop();\n    }\n    // if the first and only other argument besides the resultSelector is an array\n    // assume it's been called with `forkJoin([obs1, obs2, obs3], resultSelector)`\n    if (sources.length === 1 && isArray_1.isArray(sources[0])) {\n      sources = sources[0];\n    }\n    if (sources.length === 0) {\n      return new EmptyObservable_1.EmptyObservable();\n    }\n    return new ForkJoinObservable(sources, resultSelector);\n  };\n  /** @deprecated internal use only */\n  ForkJoinObservable.prototype._subscribe = function (subscriber) {\n    return new ForkJoinSubscriber(subscriber, this.sources, this.resultSelector);\n  };\n  return ForkJoinObservable;\n}(Observable_1.Observable);\nexports.ForkJoinObservable = ForkJoinObservable;\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\nvar ForkJoinSubscriber = function (_super) {\n  __extends(ForkJoinSubscriber, _super);\n  function ForkJoinSubscriber(destination, sources, resultSelector) {\n    _super.call(this, destination);\n    this.sources = sources;\n    this.resultSelector = resultSelector;\n    this.completed = 0;\n    this.haveValues = 0;\n    var len = sources.length;\n    this.total = len;\n    this.values = new Array(len);\n    for (var i = 0; i < len; i++) {\n      var source = sources[i];\n      var innerSubscription = subscribeToResult_1.subscribeToResult(this, source, null, i);\n      if (innerSubscription) {\n        innerSubscription.outerIndex = i;\n        this.add(innerSubscription);\n      }\n    }\n  }\n  ForkJoinSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this.values[outerIndex] = innerValue;\n    if (!innerSub._hasValue) {\n      innerSub._hasValue = true;\n      this.haveValues++;\n    }\n  };\n  ForkJoinSubscriber.prototype.notifyComplete = function (innerSub) {\n    var destination = this.destination;\n    var _a = this,\n      haveValues = _a.haveValues,\n      resultSelector = _a.resultSelector,\n      values = _a.values;\n    var len = values.length;\n    if (!innerSub._hasValue) {\n      destination.complete();\n      return;\n    }\n    this.completed++;\n    if (this.completed !== len) {\n      return;\n    }\n    if (haveValues === len) {\n      var value = resultSelector ? resultSelector.apply(this, values) : values;\n      destination.next(value);\n    }\n    destination.complete();\n  };\n  return ForkJoinSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);","map":{"version":3,"names":["__extends","d","b","p","hasOwnProperty","__","constructor","prototype","Object","create","Observable_1","require","EmptyObservable_1","isArray_1","subscribeToResult_1","OuterSubscriber_1","ForkJoinObservable","_super","sources","resultSelector","call","_i","arguments","length","EmptyObservable","pop","isArray","_subscribe","subscriber","ForkJoinSubscriber","Observable","exports","destination","completed","haveValues","len","total","values","Array","i","source","innerSubscription","subscribeToResult","outerIndex","add","notifyNext","outerValue","innerValue","innerIndex","innerSub","_hasValue","notifyComplete","_a","complete","value","apply","next","OuterSubscriber"],"sources":["C:/Users/HP/Desktop/4SE3/PidevSym/PiDev_Spring_Angular/Front-End/frontOffice/node_modules/ng5-slider/node_modules/rxjs/observable/ForkJoinObservable.js"],"sourcesContent":["\"use strict\";\r\nvar __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar Observable_1 = require('../Observable');\r\nvar EmptyObservable_1 = require('./EmptyObservable');\r\nvar isArray_1 = require('../util/isArray');\r\nvar subscribeToResult_1 = require('../util/subscribeToResult');\r\nvar OuterSubscriber_1 = require('../OuterSubscriber');\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @extends {Ignored}\r\n * @hide true\r\n */\r\nvar ForkJoinObservable = (function (_super) {\r\n    __extends(ForkJoinObservable, _super);\r\n    function ForkJoinObservable(sources, resultSelector) {\r\n        _super.call(this);\r\n        this.sources = sources;\r\n        this.resultSelector = resultSelector;\r\n    }\r\n    /* tslint:enable:max-line-length */\r\n    /**\r\n     * Joins last values emitted by passed Observables.\r\n     *\r\n     * <span class=\"informal\">Wait for Observables to complete and then combine last values they emitted.</span>\r\n     *\r\n     * <img src=\"./img/forkJoin.png\" width=\"100%\">\r\n     *\r\n     * `forkJoin` is an operator that takes any number of Observables which can be passed either as an array\r\n     * or directly as arguments. If no input Observables are provided, resulting stream will complete\r\n     * immediately.\r\n     *\r\n     * `forkJoin` will wait for all passed Observables to complete and then it will emit an array with last\r\n     * values from corresponding Observables. So if you pass `n` Observables to the operator, resulting\r\n     * array will have `n` values, where first value is the last thing emitted by the first Observable,\r\n     * second value is the last thing emitted by the second Observable and so on. That means `forkJoin` will\r\n     * not emit more than once and it will complete after that. If you need to emit combined values not only\r\n     * at the end of lifecycle of passed Observables, but also throughout it, try out {@link combineLatest}\r\n     * or {@link zip} instead.\r\n     *\r\n     * In order for resulting array to have the same length as the number of input Observables, whenever any of\r\n     * that Observables completes without emitting any value, `forkJoin` will complete at that moment as well\r\n     * and it will not emit anything either, even if it already has some last values from other Observables.\r\n     * Conversely, if there is an Observable that never completes, `forkJoin` will never complete as well,\r\n     * unless at any point some other Observable completes without emitting value, which brings us back to\r\n     * the previous case. Overall, in order for `forkJoin` to emit a value, all Observables passed as arguments\r\n     * have to emit something at least once and complete.\r\n     *\r\n     * If any input Observable errors at some point, `forkJoin` will error as well and all other Observables\r\n     * will be immediately unsubscribed.\r\n     *\r\n     * Optionally `forkJoin` accepts project function, that will be called with values which normally\r\n     * would land in emitted array. Whatever is returned by project function, will appear in output\r\n     * Observable instead. This means that default project can be thought of as a function that takes\r\n     * all its arguments and puts them into an array. Note that project function will be called only\r\n     * when output Observable is supposed to emit a result.\r\n     *\r\n     * @example <caption>Use forkJoin with operator emitting immediately</caption>\r\n     * const observable = Rx.Observable.forkJoin(\r\n     *   Rx.Observable.of(1, 2, 3, 4),\r\n     *   Rx.Observable.of(5, 6, 7, 8)\r\n     * );\r\n     * observable.subscribe(\r\n     *   value => console.log(value),\r\n     *   err => {},\r\n     *   () => console.log('This is how it ends!')\r\n     * );\r\n     *\r\n     * // Logs:\r\n     * // [4, 8]\r\n     * // \"This is how it ends!\"\r\n     *\r\n     *\r\n     * @example <caption>Use forkJoin with operator emitting after some time</caption>\r\n     * const observable = Rx.Observable.forkJoin(\r\n     *   Rx.Observable.interval(1000).take(3), // emit 0, 1, 2 every second and complete\r\n     *   Rx.Observable.interval(500).take(4) // emit 0, 1, 2, 3 every half a second and complete\r\n     * );\r\n     * observable.subscribe(\r\n     *   value => console.log(value),\r\n     *   err => {},\r\n     *   () => console.log('This is how it ends!')\r\n     * );\r\n     *\r\n     * // Logs:\r\n     * // [2, 3] after 3 seconds\r\n     * // \"This is how it ends!\" immediately after\r\n     *\r\n     *\r\n     * @example <caption>Use forkJoin with project function</caption>\r\n     * const observable = Rx.Observable.forkJoin(\r\n     *   Rx.Observable.interval(1000).take(3), // emit 0, 1, 2 every second and complete\r\n     *   Rx.Observable.interval(500).take(4), // emit 0, 1, 2, 3 every half a second and complete\r\n     *   (n, m) => n + m\r\n     * );\r\n     * observable.subscribe(\r\n     *   value => console.log(value),\r\n     *   err => {},\r\n     *   () => console.log('This is how it ends!')\r\n     * );\r\n     *\r\n     * // Logs:\r\n     * // 5 after 3 seconds\r\n     * // \"This is how it ends!\" immediately after\r\n     *\r\n     * @see {@link combineLatest}\r\n     * @see {@link zip}\r\n     *\r\n     * @param {...SubscribableOrPromise} sources Any number of Observables provided either as an array or as an arguments\r\n     * passed directly to the operator.\r\n     * @param {function} [project] Function that takes values emitted by input Observables and returns value\r\n     * that will appear in resulting Observable instead of default array.\r\n     * @return {Observable} Observable emitting either an array of last values emitted by passed Observables\r\n     * or value from project function.\r\n     * @static true\r\n     * @name forkJoin\r\n     * @owner Observable\r\n     */\r\n    ForkJoinObservable.create = function () {\r\n        var sources = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            sources[_i - 0] = arguments[_i];\r\n        }\r\n        if (sources === null || arguments.length === 0) {\r\n            return new EmptyObservable_1.EmptyObservable();\r\n        }\r\n        var resultSelector = null;\r\n        if (typeof sources[sources.length - 1] === 'function') {\r\n            resultSelector = sources.pop();\r\n        }\r\n        // if the first and only other argument besides the resultSelector is an array\r\n        // assume it's been called with `forkJoin([obs1, obs2, obs3], resultSelector)`\r\n        if (sources.length === 1 && isArray_1.isArray(sources[0])) {\r\n            sources = sources[0];\r\n        }\r\n        if (sources.length === 0) {\r\n            return new EmptyObservable_1.EmptyObservable();\r\n        }\r\n        return new ForkJoinObservable(sources, resultSelector);\r\n    };\r\n    /** @deprecated internal use only */ ForkJoinObservable.prototype._subscribe = function (subscriber) {\r\n        return new ForkJoinSubscriber(subscriber, this.sources, this.resultSelector);\r\n    };\r\n    return ForkJoinObservable;\r\n}(Observable_1.Observable));\r\nexports.ForkJoinObservable = ForkJoinObservable;\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nvar ForkJoinSubscriber = (function (_super) {\r\n    __extends(ForkJoinSubscriber, _super);\r\n    function ForkJoinSubscriber(destination, sources, resultSelector) {\r\n        _super.call(this, destination);\r\n        this.sources = sources;\r\n        this.resultSelector = resultSelector;\r\n        this.completed = 0;\r\n        this.haveValues = 0;\r\n        var len = sources.length;\r\n        this.total = len;\r\n        this.values = new Array(len);\r\n        for (var i = 0; i < len; i++) {\r\n            var source = sources[i];\r\n            var innerSubscription = subscribeToResult_1.subscribeToResult(this, source, null, i);\r\n            if (innerSubscription) {\r\n                innerSubscription.outerIndex = i;\r\n                this.add(innerSubscription);\r\n            }\r\n        }\r\n    }\r\n    ForkJoinSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\r\n        this.values[outerIndex] = innerValue;\r\n        if (!innerSub._hasValue) {\r\n            innerSub._hasValue = true;\r\n            this.haveValues++;\r\n        }\r\n    };\r\n    ForkJoinSubscriber.prototype.notifyComplete = function (innerSub) {\r\n        var destination = this.destination;\r\n        var _a = this, haveValues = _a.haveValues, resultSelector = _a.resultSelector, values = _a.values;\r\n        var len = values.length;\r\n        if (!innerSub._hasValue) {\r\n            destination.complete();\r\n            return;\r\n        }\r\n        this.completed++;\r\n        if (this.completed !== len) {\r\n            return;\r\n        }\r\n        if (haveValues === len) {\r\n            var value = resultSelector ? resultSelector.apply(this, values) : values;\r\n            destination.next(value);\r\n        }\r\n        destination.complete();\r\n    };\r\n    return ForkJoinSubscriber;\r\n}(OuterSubscriber_1.OuterSubscriber));\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}