{"ast":null,"code":"import { isUserTimingAPISupported } from './is-user-timing-api-supported';\nimport { isPerformanceObservableSupported } from './is-performance-observable-supported';\nimport { isNodeJSEnv } from './is-nodejs-env';\n// Map() is not used in order to decrease the bundle\nlet marksMap = {};\nlet marksObserver = {};\n/**\r\n * Get the current time based on User Timing API or Date\r\n *\r\n * @returns number\r\n *\r\n */\nconst getTimeNow = () => isUserTimingAPISupported ? performance.now() : Date.now();\n/**\r\n * Clear marks and measure of performance event\r\n *\r\n * @param markName - Performance marker to be checked\r\n *\r\n * @returns void\r\n *\r\n */\nconst clear = markName => {\n  marksMap[markName] = undefined;\n  // Removes PerformanceObserver references from memory\n  if (!!marksObserver[markName]) {\n    marksObserver[markName] = undefined;\n  }\n  if (!isUserTimingAPISupported) {\n    return;\n  }\n  // Some versions of NodeJS doesn't support this method\n  if (!isNodeJSEnv) {\n    performance.clearMeasures(markName);\n  }\n  performance.clearMarks(markName);\n};\n/**\r\n * Start performance measure of event\r\n *\r\n * @param markName - Performance marker to be started\r\n *\r\n * @returns number\r\n *\r\n */\nconst start = markName => {\n  if (isUserTimingAPISupported) {\n    if (isNodeJSEnv && isPerformanceObservableSupported) {\n      // eslint-disable-next-line compat/compat\n      const obs = new PerformanceObserver(list => {\n        marksObserver[markName] = list.getEntries().find(f => f.name === markName);\n        obs.disconnect();\n      });\n      obs.observe({\n        entryTypes: ['measure']\n      });\n    }\n    performance.mark(markName);\n  }\n  marksMap[markName] = getTimeNow();\n};\n/**\r\n * Finishes performance measure of event and\r\n * clear marks and measure if applicable\r\n *\r\n * @param markName - Performance marker to be checked\r\n * @param markNameToCompare - Optional mark to compare to\r\n *\r\n * @returns PerfMarksPerformanceEntry\r\n *\r\n */\nconst end = (markName, markNameToCompare) => {\n  try {\n    const startTime = marksMap[markName];\n    if (!isUserTimingAPISupported) {\n      return startTime ? {\n        duration: getTimeNow() - startTime,\n        startTime,\n        entryType: 'measure',\n        name: markName\n      } : {};\n    }\n    // If there's no User Timing mark to be compared with,\n    // the package will create one to be used for better comparison\n    if (!markNameToCompare) {\n      performance.mark(`${markName}-end`);\n    }\n    performance.measure(markName, markName, markNameToCompare || `${markName}-end`);\n    if (isNodeJSEnv) {\n      if (!!marksObserver[markName]) {\n        return marksObserver[markName];\n      }\n      return startTime ? {\n        duration: getTimeNow() - startTime,\n        startTime,\n        entryType: 'measure',\n        name: markName\n      } : {};\n    }\n    const entry = performance.getEntriesByName(markName).pop();\n    return entry || {};\n  } catch (e) {\n    // If previous mark was missing for some reason, this will throw.\n    // This could only happen if something in event loop crashed\n    // in an unexpected place earlier.\n    // Don't pile on with more errors.\n    return {};\n  } finally {\n    // Clear marks immediately to avoid growing buffer.\n    clear(markName);\n    // Clear marks used for comparison in case of it's value was passed\n    // If the mark to compare is not passed, it should remove the one we create with `-end` suffix\n    clear(markNameToCompare || `${markName}-end`);\n  }\n};\n/**\r\n * Clear all marks and measures of performance event\r\n *\r\n * @returns void\r\n *\r\n */\nconst clearAll = () => {\n  marksMap = {};\n  marksObserver = {};\n  if (!isUserTimingAPISupported) {\n    return;\n  }\n  // Some versions of NodeJS doesn't support this method\n  if (!isNodeJSEnv) {\n    performance.clearMeasures();\n  }\n  performance.clearMarks();\n};\nexport { start, end, clear, clearAll, isUserTimingAPISupported, isPerformanceObservableSupported };","map":{"version":3,"names":["isUserTimingAPISupported","isPerformanceObservableSupported","isNodeJSEnv","marksMap","marksObserver","getTimeNow","performance","now","Date","clear","markName","undefined","clearMeasures","clearMarks","start","obs","PerformanceObserver","list","getEntries","find","f","name","disconnect","observe","entryTypes","mark","end","markNameToCompare","startTime","duration","entryType","measure","entry","getEntriesByName","pop","e","clearAll"],"sources":["C:/Users/HP/Desktop/4SE3/PidevSym/PiDev_Spring_Angular/Front-End/frontOffice/node_modules/perf-marks/dist/es2020/marks.js"],"sourcesContent":["import { isUserTimingAPISupported } from './is-user-timing-api-supported';\r\nimport { isPerformanceObservableSupported } from './is-performance-observable-supported';\r\nimport { isNodeJSEnv } from './is-nodejs-env';\r\n// Map() is not used in order to decrease the bundle\r\nlet marksMap = {};\r\nlet marksObserver = {};\r\n/**\r\n * Get the current time based on User Timing API or Date\r\n *\r\n * @returns number\r\n *\r\n */\r\nconst getTimeNow = () => (isUserTimingAPISupported ? performance.now() : Date.now());\r\n/**\r\n * Clear marks and measure of performance event\r\n *\r\n * @param markName - Performance marker to be checked\r\n *\r\n * @returns void\r\n *\r\n */\r\nconst clear = (markName) => {\r\n    marksMap[markName] = undefined;\r\n    // Removes PerformanceObserver references from memory\r\n    if (!!marksObserver[markName]) {\r\n        marksObserver[markName] = undefined;\r\n    }\r\n    if (!isUserTimingAPISupported) {\r\n        return;\r\n    }\r\n    // Some versions of NodeJS doesn't support this method\r\n    if (!isNodeJSEnv) {\r\n        performance.clearMeasures(markName);\r\n    }\r\n    performance.clearMarks(markName);\r\n};\r\n/**\r\n * Start performance measure of event\r\n *\r\n * @param markName - Performance marker to be started\r\n *\r\n * @returns number\r\n *\r\n */\r\nconst start = (markName) => {\r\n    if (isUserTimingAPISupported) {\r\n        if (isNodeJSEnv && isPerformanceObservableSupported) {\r\n            // eslint-disable-next-line compat/compat\r\n            const obs = new PerformanceObserver(list => {\r\n                marksObserver[markName] = list.getEntries().find(f => f.name === markName);\r\n                obs.disconnect();\r\n            });\r\n            obs.observe({ entryTypes: ['measure'] });\r\n        }\r\n        performance.mark(markName);\r\n    }\r\n    marksMap[markName] = getTimeNow();\r\n};\r\n/**\r\n * Finishes performance measure of event and\r\n * clear marks and measure if applicable\r\n *\r\n * @param markName - Performance marker to be checked\r\n * @param markNameToCompare - Optional mark to compare to\r\n *\r\n * @returns PerfMarksPerformanceEntry\r\n *\r\n */\r\nconst end = (markName, markNameToCompare) => {\r\n    try {\r\n        const startTime = marksMap[markName];\r\n        if (!isUserTimingAPISupported) {\r\n            return startTime\r\n                ? { duration: getTimeNow() - startTime, startTime, entryType: 'measure', name: markName }\r\n                : {};\r\n        }\r\n        // If there's no User Timing mark to be compared with,\r\n        // the package will create one to be used for better comparison\r\n        if (!markNameToCompare) {\r\n            performance.mark(`${markName}-end`);\r\n        }\r\n        performance.measure(markName, markName, markNameToCompare || `${markName}-end`);\r\n        if (isNodeJSEnv) {\r\n            if (!!marksObserver[markName]) {\r\n                return marksObserver[markName];\r\n            }\r\n            return startTime\r\n                ? { duration: getTimeNow() - startTime, startTime, entryType: 'measure', name: markName }\r\n                : {};\r\n        }\r\n        const entry = performance.getEntriesByName(markName).pop();\r\n        return entry || {};\r\n    }\r\n    catch (e) {\r\n        // If previous mark was missing for some reason, this will throw.\r\n        // This could only happen if something in event loop crashed\r\n        // in an unexpected place earlier.\r\n        // Don't pile on with more errors.\r\n        return {};\r\n    }\r\n    finally {\r\n        // Clear marks immediately to avoid growing buffer.\r\n        clear(markName);\r\n        // Clear marks used for comparison in case of it's value was passed\r\n        // If the mark to compare is not passed, it should remove the one we create with `-end` suffix\r\n        clear(markNameToCompare || `${markName}-end`);\r\n    }\r\n};\r\n/**\r\n * Clear all marks and measures of performance event\r\n *\r\n * @returns void\r\n *\r\n */\r\nconst clearAll = () => {\r\n    marksMap = {};\r\n    marksObserver = {};\r\n    if (!isUserTimingAPISupported) {\r\n        return;\r\n    }\r\n    // Some versions of NodeJS doesn't support this method\r\n    if (!isNodeJSEnv) {\r\n        performance.clearMeasures();\r\n    }\r\n    performance.clearMarks();\r\n};\r\nexport { start, end, clear, clearAll, isUserTimingAPISupported, isPerformanceObservableSupported };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}