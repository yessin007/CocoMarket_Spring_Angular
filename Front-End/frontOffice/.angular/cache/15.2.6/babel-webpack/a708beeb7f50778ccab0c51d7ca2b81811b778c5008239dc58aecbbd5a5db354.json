{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\r\n * Groups pairs of consecutive emissions together and emits them as an array of\r\n * two values.\r\n *\r\n * <span class=\"informal\">Puts the current value and previous value together as\r\n * an array, and emits that.</span>\r\n *\r\n * <img src=\"./img/pairwise.png\" width=\"100%\">\r\n *\r\n * The Nth emission from the source Observable will cause the output Observable\r\n * to emit an array [(N-1)th, Nth] of the previous and the current value, as a\r\n * pair. For this reason, `pairwise` emits on the second and subsequent\r\n * emissions from the source Observable, but not on the first emission, because\r\n * there is no previous value in that case.\r\n *\r\n * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>\r\n * var clicks = Rx.Observable.fromEvent(document, 'click');\r\n * var pairs = clicks.pairwise();\r\n * var distance = pairs.map(pair => {\r\n *   var x0 = pair[0].clientX;\r\n *   var y0 = pair[0].clientY;\r\n *   var x1 = pair[1].clientX;\r\n *   var y1 = pair[1].clientY;\r\n *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));\r\n * });\r\n * distance.subscribe(x => console.log(x));\r\n *\r\n * @see {@link buffer}\r\n * @see {@link bufferCount}\r\n *\r\n * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of\r\n * consecutive values from the source Observable.\r\n * @method pairwise\r\n * @owner Observable\r\n */\nfunction pairwise() {\n  return function (source) {\n    return source.lift(new PairwiseOperator());\n  };\n}\nexports.pairwise = pairwise;\nvar PairwiseOperator = function () {\n  function PairwiseOperator() {}\n  PairwiseOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new PairwiseSubscriber(subscriber));\n  };\n  return PairwiseOperator;\n}();\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\nvar PairwiseSubscriber = function (_super) {\n  __extends(PairwiseSubscriber, _super);\n  function PairwiseSubscriber(destination) {\n    _super.call(this, destination);\n    this.hasPrev = false;\n  }\n  PairwiseSubscriber.prototype._next = function (value) {\n    if (this.hasPrev) {\n      this.destination.next([this.prev, value]);\n    } else {\n      this.hasPrev = true;\n    }\n    this.prev = value;\n  };\n  return PairwiseSubscriber;\n}(Subscriber_1.Subscriber);","map":{"version":3,"names":["__extends","d","b","p","hasOwnProperty","__","constructor","prototype","Object","create","Subscriber_1","require","pairwise","source","lift","PairwiseOperator","exports","call","subscriber","subscribe","PairwiseSubscriber","_super","destination","hasPrev","_next","value","next","prev","Subscriber"],"sources":["C:/Users/HP/Desktop/4SE3/PidevSym/PiDev_Spring_Angular/Front-End/frontOffice/node_modules/ng5-slider/node_modules/rxjs/operators/pairwise.js"],"sourcesContent":["\"use strict\";\r\nvar __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar Subscriber_1 = require('../Subscriber');\r\n/**\r\n * Groups pairs of consecutive emissions together and emits them as an array of\r\n * two values.\r\n *\r\n * <span class=\"informal\">Puts the current value and previous value together as\r\n * an array, and emits that.</span>\r\n *\r\n * <img src=\"./img/pairwise.png\" width=\"100%\">\r\n *\r\n * The Nth emission from the source Observable will cause the output Observable\r\n * to emit an array [(N-1)th, Nth] of the previous and the current value, as a\r\n * pair. For this reason, `pairwise` emits on the second and subsequent\r\n * emissions from the source Observable, but not on the first emission, because\r\n * there is no previous value in that case.\r\n *\r\n * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>\r\n * var clicks = Rx.Observable.fromEvent(document, 'click');\r\n * var pairs = clicks.pairwise();\r\n * var distance = pairs.map(pair => {\r\n *   var x0 = pair[0].clientX;\r\n *   var y0 = pair[0].clientY;\r\n *   var x1 = pair[1].clientX;\r\n *   var y1 = pair[1].clientY;\r\n *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));\r\n * });\r\n * distance.subscribe(x => console.log(x));\r\n *\r\n * @see {@link buffer}\r\n * @see {@link bufferCount}\r\n *\r\n * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of\r\n * consecutive values from the source Observable.\r\n * @method pairwise\r\n * @owner Observable\r\n */\r\nfunction pairwise() {\r\n    return function (source) { return source.lift(new PairwiseOperator()); };\r\n}\r\nexports.pairwise = pairwise;\r\nvar PairwiseOperator = (function () {\r\n    function PairwiseOperator() {\r\n    }\r\n    PairwiseOperator.prototype.call = function (subscriber, source) {\r\n        return source.subscribe(new PairwiseSubscriber(subscriber));\r\n    };\r\n    return PairwiseOperator;\r\n}());\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @ignore\r\n * @extends {Ignored}\r\n */\r\nvar PairwiseSubscriber = (function (_super) {\r\n    __extends(PairwiseSubscriber, _super);\r\n    function PairwiseSubscriber(destination) {\r\n        _super.call(this, destination);\r\n        this.hasPrev = false;\r\n    }\r\n    PairwiseSubscriber.prototype._next = function (value) {\r\n        if (this.hasPrev) {\r\n            this.destination.next([this.prev, value]);\r\n        }\r\n        else {\r\n            this.hasPrev = true;\r\n        }\r\n        this.prev = value;\r\n    };\r\n    return PairwiseSubscriber;\r\n}(Subscriber_1.Subscriber));\r\n"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,SAAS,GAAI,IAAI,IAAI,IAAI,CAACA,SAAS,IAAK,UAAUC,CAAC,EAAEC,CAAC,EAAE;EACxD,KAAK,IAAIC,CAAC,IAAID,CAAC,EAAE,IAAIA,CAAC,CAACE,cAAc,CAACD,CAAC,CAAC,EAAEF,CAAC,CAACE,CAAC,CAAC,GAAGD,CAAC,CAACC,CAAC,CAAC;EACrD,SAASE,EAAE,GAAG;IAAE,IAAI,CAACC,WAAW,GAAGL,CAAC;EAAE;EACtCA,CAAC,CAACM,SAAS,GAAGL,CAAC,KAAK,IAAI,GAAGM,MAAM,CAACC,MAAM,CAACP,CAAC,CAAC,IAAIG,EAAE,CAACE,SAAS,GAAGL,CAAC,CAACK,SAAS,EAAE,IAAIF,EAAE,EAAE,CAAC;AACxF,CAAC;AACD,IAAIK,YAAY,GAAGC,OAAO,CAAC,eAAe,CAAC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,QAAQ,GAAG;EAChB,OAAO,UAAUC,MAAM,EAAE;IAAE,OAAOA,MAAM,CAACC,IAAI,CAAC,IAAIC,gBAAgB,EAAE,CAAC;EAAE,CAAC;AAC5E;AACAC,OAAO,CAACJ,QAAQ,GAAGA,QAAQ;AAC3B,IAAIG,gBAAgB,GAAI,YAAY;EAChC,SAASA,gBAAgB,GAAG,CAC5B;EACAA,gBAAgB,CAACR,SAAS,CAACU,IAAI,GAAG,UAAUC,UAAU,EAAEL,MAAM,EAAE;IAC5D,OAAOA,MAAM,CAACM,SAAS,CAAC,IAAIC,kBAAkB,CAACF,UAAU,CAAC,CAAC;EAC/D,CAAC;EACD,OAAOH,gBAAgB;AAC3B,CAAC,EAAG;AACJ;AACA;AACA;AACA;AACA;AACA,IAAIK,kBAAkB,GAAI,UAAUC,MAAM,EAAE;EACxCrB,SAAS,CAACoB,kBAAkB,EAAEC,MAAM,CAAC;EACrC,SAASD,kBAAkB,CAACE,WAAW,EAAE;IACrCD,MAAM,CAACJ,IAAI,CAAC,IAAI,EAAEK,WAAW,CAAC;IAC9B,IAAI,CAACC,OAAO,GAAG,KAAK;EACxB;EACAH,kBAAkB,CAACb,SAAS,CAACiB,KAAK,GAAG,UAAUC,KAAK,EAAE;IAClD,IAAI,IAAI,CAACF,OAAO,EAAE;MACd,IAAI,CAACD,WAAW,CAACI,IAAI,CAAC,CAAC,IAAI,CAACC,IAAI,EAAEF,KAAK,CAAC,CAAC;IAC7C,CAAC,MACI;MACD,IAAI,CAACF,OAAO,GAAG,IAAI;IACvB;IACA,IAAI,CAACI,IAAI,GAAGF,KAAK;EACrB,CAAC;EACD,OAAOL,kBAAkB;AAC7B,CAAC,CAACV,YAAY,CAACkB,UAAU,CAAE"},"metadata":{},"sourceType":"script","externalDependencies":[]}